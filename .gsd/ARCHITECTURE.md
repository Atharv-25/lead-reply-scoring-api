# Architecture

> Auto-generated by /map on 2026-02-23

## Overview

The Lead Reply Scoring API is a fast, unified intelligence engine designed to parse, score, and classify inbound lead replies. It determines the buying intent, urgency, and recommended action (e.g., respond now, respond later, do not respond) for each lead based on keyword detection, conversational signals, and strict recency and frequency logic.

```text
┌─────────────────────────────────────────┐
│        [Entry Point: FastAPI App]       │
│               (main.py)                 │
├─────────────────────────────────────────┤
│         [Business Logic Layer]          │
│         (reply_intelligence.py)         │
├─────────────────────────────────────────┤
│            [Data Layer]                 │
│         (lead_memory.json - File)       │
└─────────────────────────────────────────┘
```

## Components

### API Server (`main.py`)
- **Purpose:** Exposes endpoints for single lead scoring (`/score`), batch CSV scoring (`/score-batch-csv`), and a beta summary mode (`/beta-summary-json`).
- **Dependencies:** `fastapi`, `reply_intelligence.py`, `csv`

### Reply Intelligence Engine (`reply_intelligence.py`)
- **Purpose:** Extracts signals from text, calculates metrics (velocity, depth), applies heuristic rules, and enforces persistence/hardening mechanisms like duplicate suppression and strict recency.
- **Location:** `reply_intelligence.py`
- **Dependencies:** `re`, `json`, `os`, `time`, `datetime`

### Testing Ecosystem (`tests/` & root `test_*.py`)
- **Purpose:** Validates engine logic, email verification routing, and API limits. There are numerous synthetic, stress, and chaos tests.

## Data Flow

1. **Ingestion:** Lead text (and metadata) enters the system via REST endpoint (`main.py`).
2. **Terminal Checks:** `reply_intelligence.py` checks for "Ready Now" buying commands or explicit unsubscribe ("Noise") patterns.
3. **Signal Extraction:** Heuristics match signal families (Financial, Urgency, Validation, Authority, Need).
4. **Scoring & Classification:** Calculates a normalized score (0-100) and assigns a tier (e.g., Ready Now, Right ICP / Wrong Timing, Noise).
5. **Inbox Reality (Hardening):** Duplicate suppression checks local `lead_memory.json`. Recency bonuses are applied based on `created_at`.
6. **Output:** Returns priority score, level, action, tier, and generated explanations.

## Integration Points

| Service | Type | Purpose |
|---------|------|---------|
| Local File Storage | Persistence | Saves `lead_memory.json` to track recent actions for duplicate suppression. |
| Local File Storage | Logging | Logs unknown signals to `unknown_signals.log` and batch metrics to `batch_metrics.log`. |

## Technical Debt

- [ ] **Test File Organization:** Multiple test and synthetic script files (`test_hardening.py`, `synthetic_round2.py`, etc.) are in the root directory instead of the `tests/` folder.
- [ ] **Persistence Method:** Uses local JSON files (`lead_memory.json`, `unknown_signals.log`) for state and persistence. This will not scale in a multi-instance, stateless deployment environment (e.g., Docker/Kubernetes). A proper database or cache (e.g., Redis) is needed.
- [ ] **Log File Management:** Logs and memory files are written directly to the execution directory.

## Conventions

**Naming:** Python snake_case for methods, UPPER_CASE for configuration and constants.
**Structure:** Monolithic script layout for core functionality.
**Testing:** Combination of unit tests (using `unittest` or direct script execution) and synthetic batch simulators.
